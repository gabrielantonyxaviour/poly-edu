/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type { TypedEventFilter, TypedEvent, TypedListener } from "./common";

interface RouterSequencerCrossTalkUpgradeableInterface
  extends ethers.utils.Interface {
  functions: {
    "Link(uint8,address)": FunctionFragment;
    "Unlink(uint8)": FunctionFragment;
    "fetchErcHandler()": FunctionFragment;
    "fetchExecutes(bytes32)": FunctionFragment;
    "fetchFeeToken()": FunctionFragment;
    "fetchLink(uint8)": FunctionFragment;
    "fetchLinkSetter()": FunctionFragment;
    "fetchReserveHandler()": FunctionFragment;
    "fetchSequencerHandler()": FunctionFragment;
    "routerSync(uint8,address,bytes)": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "transferAmt(bytes,address)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "Link",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "Unlink",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "fetchErcHandler",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "fetchExecutes",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fetchFeeToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "fetchLink",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "fetchLinkSetter",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "fetchReserveHandler",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "fetchSequencerHandler",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "routerSync",
    values: [BigNumberish, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transferAmt",
    values: [BytesLike, string]
  ): string;

  decodeFunctionResult(functionFragment: "Link", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Unlink", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fetchErcHandler",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fetchExecutes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fetchFeeToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fetchLink", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fetchLinkSetter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fetchReserveHandler",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fetchSequencerHandler",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "routerSync", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferAmt",
    data: BytesLike
  ): Result;

  events: {
    "CrossTalkReceive(uint8,uint8,address)": EventFragment;
    "CrossTalkSend(uint8,tuple,address,address,bytes4,bytes32)": EventFragment;
    "Linkevent(uint8,address)": EventFragment;
    "Unlinkevent(uint8,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "CrossTalkReceive"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CrossTalkSend"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Linkevent"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unlinkevent"): EventFragment;
}

export type CrossTalkReceiveEvent = TypedEvent<
  [number, number, string] & {
    sourceChain: number;
    destChain: number;
    sourceAddress: string;
  }
>;

export type CrossTalkSendEvent = TypedEvent<
  [
    number,
    [
      number,
      string,
      string,
      string,
      BigNumber,
      BigNumber,
      string,
      boolean,
      boolean
    ] & {
      _destChainID: number;
      _erc20: string;
      _swapData: string;
      _generic: string;
      _gasLimit: BigNumber;
      _gasPrice: BigNumber;
      _feeToken: string;
      _isTransferFirst: boolean;
      _isOnlyGeneric: boolean;
    },
    string,
    string,
    string,
    string
  ] & {
    sourceChain: number;
    params: [
      number,
      string,
      string,
      string,
      BigNumber,
      BigNumber,
      string,
      boolean,
      boolean
    ] & {
      _destChainID: number;
      _erc20: string;
      _swapData: string;
      _generic: string;
      _gasLimit: BigNumber;
      _gasPrice: BigNumber;
      _feeToken: string;
      _isTransferFirst: boolean;
      _isOnlyGeneric: boolean;
    };
    sourceAddress: string;
    destinationAddress: string;
    _selector: string;
    _hash: string;
  }
>;

export type LinkeventEvent = TypedEvent<
  [number, string] & { ChainID: number; linkedContract: string }
>;

export type UnlinkeventEvent = TypedEvent<
  [number, string] & { ChainID: number; linkedContract: string }
>;

export class RouterSequencerCrossTalkUpgradeable extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: RouterSequencerCrossTalkUpgradeableInterface;

  functions: {
    Link(
      _chainID: BigNumberish,
      _linkedContract: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    Unlink(
      _chainID: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fetchErcHandler(overrides?: CallOverrides): Promise<[string]>;

    fetchExecutes(
      hash: BytesLike,
      overrides?: CallOverrides
    ): Promise<[[number, BigNumber] & { chainID: number; nonce: BigNumber }]>;

    fetchFeeToken(overrides?: CallOverrides): Promise<[string]>;

    fetchLink(
      _chainID: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    fetchLinkSetter(overrides?: CallOverrides): Promise<[string]>;

    fetchReserveHandler(overrides?: CallOverrides): Promise<[string]>;

    fetchSequencerHandler(overrides?: CallOverrides): Promise<[string]>;

    routerSync(
      srcChainID: BigNumberish,
      srcAddress: string,
      genericData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    transferAmt(
      data: BytesLike,
      sender: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  Link(
    _chainID: BigNumberish,
    _linkedContract: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  Unlink(
    _chainID: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fetchErcHandler(overrides?: CallOverrides): Promise<string>;

  fetchExecutes(
    hash: BytesLike,
    overrides?: CallOverrides
  ): Promise<[number, BigNumber] & { chainID: number; nonce: BigNumber }>;

  fetchFeeToken(overrides?: CallOverrides): Promise<string>;

  fetchLink(_chainID: BigNumberish, overrides?: CallOverrides): Promise<string>;

  fetchLinkSetter(overrides?: CallOverrides): Promise<string>;

  fetchReserveHandler(overrides?: CallOverrides): Promise<string>;

  fetchSequencerHandler(overrides?: CallOverrides): Promise<string>;

  routerSync(
    srcChainID: BigNumberish,
    srcAddress: string,
    genericData: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  supportsInterface(
    interfaceId: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  transferAmt(
    data: BytesLike,
    sender: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    Link(
      _chainID: BigNumberish,
      _linkedContract: string,
      overrides?: CallOverrides
    ): Promise<void>;

    Unlink(_chainID: BigNumberish, overrides?: CallOverrides): Promise<void>;

    fetchErcHandler(overrides?: CallOverrides): Promise<string>;

    fetchExecutes(
      hash: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number, BigNumber] & { chainID: number; nonce: BigNumber }>;

    fetchFeeToken(overrides?: CallOverrides): Promise<string>;

    fetchLink(
      _chainID: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    fetchLinkSetter(overrides?: CallOverrides): Promise<string>;

    fetchReserveHandler(overrides?: CallOverrides): Promise<string>;

    fetchSequencerHandler(overrides?: CallOverrides): Promise<string>;

    routerSync(
      srcChainID: BigNumberish,
      srcAddress: string,
      genericData: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean, string]>;

    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    transferAmt(
      data: BytesLike,
      sender: string,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "CrossTalkReceive(uint8,uint8,address)"(
      sourceChain?: BigNumberish | null,
      destChain?: BigNumberish | null,
      sourceAddress?: null
    ): TypedEventFilter<
      [number, number, string],
      { sourceChain: number; destChain: number; sourceAddress: string }
    >;

    CrossTalkReceive(
      sourceChain?: BigNumberish | null,
      destChain?: BigNumberish | null,
      sourceAddress?: null
    ): TypedEventFilter<
      [number, number, string],
      { sourceChain: number; destChain: number; sourceAddress: string }
    >;

    "CrossTalkSend(uint8,tuple,address,address,bytes4,bytes32)"(
      sourceChain?: BigNumberish | null,
      params?: null,
      sourceAddress?: null,
      destinationAddress?: null,
      _selector?: BytesLike | null,
      _hash?: null
    ): TypedEventFilter<
      [
        number,
        [
          number,
          string,
          string,
          string,
          BigNumber,
          BigNumber,
          string,
          boolean,
          boolean
        ] & {
          _destChainID: number;
          _erc20: string;
          _swapData: string;
          _generic: string;
          _gasLimit: BigNumber;
          _gasPrice: BigNumber;
          _feeToken: string;
          _isTransferFirst: boolean;
          _isOnlyGeneric: boolean;
        },
        string,
        string,
        string,
        string
      ],
      {
        sourceChain: number;
        params: [
          number,
          string,
          string,
          string,
          BigNumber,
          BigNumber,
          string,
          boolean,
          boolean
        ] & {
          _destChainID: number;
          _erc20: string;
          _swapData: string;
          _generic: string;
          _gasLimit: BigNumber;
          _gasPrice: BigNumber;
          _feeToken: string;
          _isTransferFirst: boolean;
          _isOnlyGeneric: boolean;
        };
        sourceAddress: string;
        destinationAddress: string;
        _selector: string;
        _hash: string;
      }
    >;

    CrossTalkSend(
      sourceChain?: BigNumberish | null,
      params?: null,
      sourceAddress?: null,
      destinationAddress?: null,
      _selector?: BytesLike | null,
      _hash?: null
    ): TypedEventFilter<
      [
        number,
        [
          number,
          string,
          string,
          string,
          BigNumber,
          BigNumber,
          string,
          boolean,
          boolean
        ] & {
          _destChainID: number;
          _erc20: string;
          _swapData: string;
          _generic: string;
          _gasLimit: BigNumber;
          _gasPrice: BigNumber;
          _feeToken: string;
          _isTransferFirst: boolean;
          _isOnlyGeneric: boolean;
        },
        string,
        string,
        string,
        string
      ],
      {
        sourceChain: number;
        params: [
          number,
          string,
          string,
          string,
          BigNumber,
          BigNumber,
          string,
          boolean,
          boolean
        ] & {
          _destChainID: number;
          _erc20: string;
          _swapData: string;
          _generic: string;
          _gasLimit: BigNumber;
          _gasPrice: BigNumber;
          _feeToken: string;
          _isTransferFirst: boolean;
          _isOnlyGeneric: boolean;
        };
        sourceAddress: string;
        destinationAddress: string;
        _selector: string;
        _hash: string;
      }
    >;

    "Linkevent(uint8,address)"(
      ChainID?: BigNumberish | null,
      linkedContract?: string | null
    ): TypedEventFilter<
      [number, string],
      { ChainID: number; linkedContract: string }
    >;

    Linkevent(
      ChainID?: BigNumberish | null,
      linkedContract?: string | null
    ): TypedEventFilter<
      [number, string],
      { ChainID: number; linkedContract: string }
    >;

    "Unlinkevent(uint8,address)"(
      ChainID?: BigNumberish | null,
      linkedContract?: string | null
    ): TypedEventFilter<
      [number, string],
      { ChainID: number; linkedContract: string }
    >;

    Unlinkevent(
      ChainID?: BigNumberish | null,
      linkedContract?: string | null
    ): TypedEventFilter<
      [number, string],
      { ChainID: number; linkedContract: string }
    >;
  };

  estimateGas: {
    Link(
      _chainID: BigNumberish,
      _linkedContract: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    Unlink(
      _chainID: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fetchErcHandler(overrides?: CallOverrides): Promise<BigNumber>;

    fetchExecutes(
      hash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fetchFeeToken(overrides?: CallOverrides): Promise<BigNumber>;

    fetchLink(
      _chainID: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fetchLinkSetter(overrides?: CallOverrides): Promise<BigNumber>;

    fetchReserveHandler(overrides?: CallOverrides): Promise<BigNumber>;

    fetchSequencerHandler(overrides?: CallOverrides): Promise<BigNumber>;

    routerSync(
      srcChainID: BigNumberish,
      srcAddress: string,
      genericData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferAmt(
      data: BytesLike,
      sender: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    Link(
      _chainID: BigNumberish,
      _linkedContract: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    Unlink(
      _chainID: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fetchErcHandler(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    fetchExecutes(
      hash: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fetchFeeToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    fetchLink(
      _chainID: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fetchLinkSetter(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    fetchReserveHandler(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fetchSequencerHandler(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    routerSync(
      srcChainID: BigNumberish,
      srcAddress: string,
      genericData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    transferAmt(
      data: BytesLike,
      sender: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
